#include <X11/X.h>
#include <X11/Xlib.h>
#include <X11/keysym.h>
#include <stdio.h>
#include <unistd.h>
#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "bat3.h"

// copyright (c)2006 Technologic Systems
// Author: Michael Schmidt

/*
  This is a simple example of what can be done with the battery information
  generated by the bat3save program.  It opens a simple X windows window
  and plots voltage, current and a few other things in different colors.
  The program terminates when the window is clicked on, and no attempt is
  made to repaint the screen if it is needed.

  
  The arguments to this program are:
  samples_to_average offset samples_per_pixel

  The program basically combines <samples_to_average> samples at a time
  into a single sample, displays the value at the current x offset if
  the sample number is greater then "offset", and then  increments the 
  sample count.  Every "samples_per_pixel" averages samples, the x ofset
  is incremented.
 */

FILE *f = 0;
bat3Info b[256];

// normalize battery voltage (~4 -> 4)
float nV(float f) {
  return f;
}

// normalize battery current (~800000 -> 4)
float nI(int i) {
  return (float)i / 200000;
}

// normalize temperature (~90 -> 4.5)
float nT(float f) {
  return f/20;
}

int miny=150,maxy=1150,maxx=1585;

int draw(Display *dsp,Window win,GC gc,int SAMPLES,int start_sample,int step) {
  FILE *f;
  int i = 0,j,start=0,stepi=0;
  float V,I,F,dVdT;
  int lastI = 0;
  char text[256];
  long eventMask;
  XEvent evt;
  long seekto = 0,seekat;
  int starttime = 0;
  float tmp=0;

  for (i=0;i<255;i++) text[i] = ' '; i = 0;
  eventMask = ButtonPressMask|ButtonReleaseMask;
  XSelectInput(dsp,win,eventMask); // override prev

  f = fopen("bat.dat","r");
  if (!f) {
    perror("fopen:");
    return 1;
  }
 redraw:
  //printf("#,V,I,F\n");
  while (!feof(f)) {
    if (fread(&b,sizeof(bat3Info),SAMPLES,f) == SAMPLES) {
      if (starttime == 0) {
	starttime = b[0].t;
      }
      V = nV(b[0].battV);
      I = nI(b[0].battI);
      F = nT(b[0].tempF);
      
      if (I < 0.0) I = -I;
      if (start++ > start_sample  && b[0].pwm1en ) {
	//printf("%d, %d %d %d\n",i,(int)V*100,(int)I*100,(int)F*100);
	lastI = b[0].battI;
	XSetForeground( dsp, gc, 0xFF0000 );
	XDrawPoint(dsp, win, gc, i, maxy - (int)(V*150));
	XSetForeground( dsp, gc, 0xFF );
	XDrawPoint(dsp, win, gc, i, maxy - (int)(I*100) - miny -0);
	XSetForeground( dsp, gc, 0xFF00 );
	XDrawPoint(dsp, win, gc, i, maxy - (int)(F*100));
	XSetForeground( dsp, gc, 0x808080 );
	XDrawPoint(dsp, win, gc, i, maxy-miny-((b[0].t-starttime)/10) % (maxy-miny));
	XSetForeground( dsp, gc, 0xFFFF );
	XDrawPoint(dsp, win, gc, i, (maxy-miny)*(b[0].pwmlo/b[0].pwmt));
	if (I != 0) {
	  if (1 || tmp == 0 || b[0].locked == 0) {
	    tmp = 100*V/I;
	  } else {
	    tmp = tmp * 0.0 / 16.0 + 16.0/16.0 * (100*V/I);
	  }
	  XSetForeground( dsp, gc, 0xFF80 );
	  XDrawPoint(dsp, win, gc, i, tmp);
	}
	//printf("%d,%.2f,%.3f,%.2f\n",i,V,I,F);
	if (stepi++ == step) {
	  i++;
	  stepi = 0;
	}
      }
    }
  }
  XSetForeground( dsp, gc, 0xFFFFFF );
  XDrawString(dsp,win,gc,10,10,text,strlen(text));
  XSetForeground( dsp, gc, 0 );
  sprintf(text,"%d samples",start);
  XDrawString(dsp,win,gc,10,10,text,strlen(text));
  XSync(dsp,1);

  seekto = ftell(f);
  do {
    fseek(f,0,SEEK_END);
    seekat = ftell(f);
    if (XCheckWindowEvent(dsp,win,eventMask,&evt)) {
      goto drawdone;
    }
  } while (seekto == seekat);
  fseek(f,seekto,SEEK_SET);
  goto redraw;
 drawdone:
  fclose(f);
  /*
 
  do{
    XNextEvent( dsp, &evt );   // calls XFlush()
    
  }while( evt.type != ButtonRelease );
  */
  return 0;
}

int main(int argc,char *argv[]){
  int i,sample_size=1, start_sample=0, step=31;
  int screenNumber;
  Display *dsp;
  Window win;
  long eventMask;
  XEvent evt;

  if (argc == 4) {
    sample_size = atoi(argv[1]);
    start_sample = atoi(argv[2]);
    step = atoi(argv[3]);
  }
  dsp = XOpenDisplay( NULL );
  if( !dsp ){ return 1; }


  screenNumber = DefaultScreen(dsp);

  win = XCreateSimpleWindow(dsp,
                               DefaultRootWindow(dsp),
                               0, 0,   // origin
                               maxx, maxy-miny, // size
                               0, 0x000000, // border
                               0xFFFFFF );  // backgd

  XMapWindow( dsp, win );


  eventMask = StructureNotifyMask;
  XSelectInput( dsp, win, eventMask );

  do{
    XNextEvent( dsp, &evt );   // calls XFlush
  }while( evt.type != MapNotify );


  GC gc = XCreateGC( dsp, win,
                     0,        // mask of values
                     NULL );   // array of values
  XSetForeground( dsp, gc, 0xF0F0F0 );
  for (i=0;i<maxy-miny;i+=5) {
    XDrawLine(dsp,win,gc,0,i,maxx,i);
  }
  for (i=0;i<maxx;i+=20) {
    XDrawLine(dsp,win,gc,i,0,i,maxy-miny);
  }

  XSetForeground( dsp, gc, 0xE0E0E0 );

  for (i=0;i<maxy-miny;i+=25) {
    XDrawLine(dsp,win,gc,0,i,maxx,i);
  }
  for (i=0;i<maxx;i+=100) {
    XDrawLine(dsp,win,gc,i,0,i,maxy-miny);
  }

  draw(dsp,win,gc,sample_size,start_sample, step);



  XDestroyWindow( dsp, win );
  XCloseDisplay( dsp );

  return 0;
}

/*
 * $Id$
 *
 * $LastChangedDate$
 * $Rev$
 * $Author$
 *
 * */
